# 聚合 - 第四期

## 回顾

- ES 索引(Index) => 表
- ES 字段(Field) => 列
- 倒排索引

## 分词器

分词的一种规则

### 空格分词器 - whitespace

```bash
POST _analyze
{
  "analyzer": "whitespace",
  "text":     "The quick brown fox."
}
```

The quick brown fox.

->

The、quick、brown、fox

### ~~标准分词规则~~（不用）

```bash
POST _analyze
{
  "tokenizer": "standard",
  "filter":  [ "lowercase", "asciifolding" ],
  "text":      "Is this déja vu?"
}
```

### 自定义分词器 ( 不用 )

### 关键字分词器: 就是不分词,整句话当作专业术语

### IK分词器(中文分词器)

提供了两种分词器

- ik_smart
- ik_max_word

## 打分机制

三条内容:

1、 鱼皮是狗

2、 鱼皮是小黑子

3、 我是小黑子

搜索：

1、 鱼皮 -> 第一条（匹配比例大）

2、 鱼皮小黑子 -> 第二条 （2 > 3 > 1）

### Java操作ES

1) ES官方API

2) HighLevelRestClient

3) Spring Data ElasticSearch

#### Spring Data 系列: spring提供的一系列操作数据的框架

如:

spring-data-redis

spring-data-mongpdb

spring-data-elasticsearch

#### Spring Data ElasticSearch

自定义方法:

用户可以指定接口的方法名称,框架自动生成查询代码

#### 用ES实现搜索接口

1、建表 （ 建立index ）

```mysql
create table if not exists cyt_so.post
(
    id         bigint auto_increment comment 'id'
        primary key,
    title      varchar(512)                       null comment '标题',
    content    text                               null comment '内容',
    tags       varchar(1024)                      null comment '标签列表（json 数组）',
    thumbNum   int      default 0                 not null comment '点赞数',
    favourNum  int      default 0                 not null comment '收藏数',
    userId     bigint                             not null comment '创建用户 id',
    createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete   tinyint  default 0                 not null comment '是否删除'
)
    comment '帖子';
```

#### 字段解释

- aliases：别名 （为了方便数据迁移）
- text： 文本 （可被分词）
- text中还有一个fields字段：
    - 它是为了：为了让text类型的分词字段支持精确查询，可以创建keyword的子字段
    - ignore_above：字符超越限制

```json
put /post_v1
{
  "aliases": {
    "post": {}
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "ik_max_word",
        // 存储分词器
        "search_analyzer": "ik_smart",
        // 搜索分词器 
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "content": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "tags": {
        "type": "keyword"
      },
      "userId": {
        "type": "keyword"
      },
      "createTime": {
        "type": "date"
      },
      "updateTime": {
        "type": "date"
      },
      "isDelete": {
        "type": "keyword"
      }
    }
  }
}
```

#### 增删改查

- 方式一：ElasticsearchRepository<PostEsDTO, Long> ： 默认提供了简单的增删改查，多用于可预期的，没那么复杂的查询、自定义查询
- 方式二：Spring默认提供的，也提供了增删改查。参数更灵活（ 多用于复杂操作 ）

ESDao中，_开头的字段是系统提供的字段，比如_id，如果人手动不指定，系统会自动生成，但是不会在_source字段中补充id的值（即，不会和存储的内容同步），所以建议手动指定

并且支持根据方法名自动生成方法，比如

```java
    List<PostEsDTO> findByTitle(String title);
```

**而对于复杂的查询，建议用第二种方式。**

- 三步
    - 1、取参数
    - 2、把参数组合成ES支持的搜索条件
    - 3、从返回值中获取结果

查询DSL

```json
GET /_search
{
  "query": {
    "bool": {
      "must": [
        // must表示必须满足
        {
          "match": {
            "title": "Search"
          }
        },
        // match表示模糊匹配
        {
          "match": {
            "content": "Elasticsearch"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "status": "published"
          }
        },
        // tern表示精确查询
        {
          "range": {
            "publish_date": {
              "gte": "2015-01-01"
            }
          }
        }
      ]
    }
  }
}
```

wildcard 模糊查询

regexp 正则匹配查询

- 查询结果中的_score就是匹配分数

##### 标准查询语句

```json
POST _search
{
  "query": {
    "bool": {
      "should": [
        {
          "term": {
            "a": "A"
          }
        },
        {
          "term": {
            "b": "B"
          }
        }
      ],
      "should": [
        {
          "term": {
            "c": "C"
          }
        },
        {
          "term": {
            "d": "D"
          }
        }
      ],
      "minimum_should_match": 1,
      "boost": 1.0
    }
  }
}
```

本项目的查询语句

```json
{
  "query": {
    "bool": {
      "must_not": [
        {
          "match": {
            "title": ""
          }
        }
      ],
      "should": [
        {
          "match": {
            "title": ""
          }
        },
        {
          "match": {
            "desc": ""
          }
        }
      ],
      "filter": [
        {
          "term": {
            "isDelete": 0
          }
        },
        {
          "term": {
            "id": 1
          }
        },
        {
          "term": {
            "tags": "java"
          }
        },
        {
          "term": {
            "tags": "框架"
          }
        }
      ],
      "minimum_should_match": 0
    }
  },
  "from": 0,
  //分⻚
  "size": 5,
  //分⻚
  "_source": [
    "name",
    "_createtime",
    "desc",
    "reviewStatus",
    "priority",
    "tags"
  ],
  //要查的字段
  "sort": [
    //排序
    {
      "priority": {
        "order": "desc"
      }
    },
    {
      "_score": {
        "order": "desc"
      }
    },
    {
      "publishTime": {
        "order": "desc"
      }
    }
  ]
}
```

然后翻译成java (在postService.searchFromEs()方法中)

```java
String sortField=postQueryRequest.getSortField();
        String sortOrder=postQueryRequest.getSortOrder();
        BoolQueryBuilder boolQueryBuilder=QueryBuilders.boolQuery();
        // 过滤
        boolQueryBuilder.filter(QueryBuilders.termQuery("isDelete",0));
        if(id!=null){
        boolQueryBuilder.filter(QueryBuilders.termQuery("id",id));
        }
        if(notId!=null){
        boolQueryBuilder.mustNot(QueryBuilders.termQuery("id",notId));
        }
        if(userId!=null){
        boolQueryBuilder.filter(QueryBuilders.termQuery("userId",userId));
        }
        // 必须包含所有标签
        if(CollectionUtils.isNotEmpty(tagList)){
        for(String tag:tagList){
        boolQueryBuilder.filter(QueryBuilders.termQuery("tags",tag));
        }
        }
        // 包含任何一个标签即可
        if(CollectionUtils.isNotEmpty(orTagList)){
        BoolQueryBuilder orTagBoolQueryBuilder=QueryBuilders.boolQuery();
        for(String tag:orTagList){
        orTagBoolQueryBuilder.should(QueryBuilders.termQuery("tags",tag));
        }
        orTagBoolQueryBuilder.minimumShouldMatch(1);
        boolQueryBuilder.filter(orTagBoolQueryBuilder);
        }
        // 按关键词检索
        if(StringUtils.isNotBlank(searchText)){
        boolQueryBuilder.should(QueryBuilders.matchQuery("title",searchText));
        boolQueryBuilder.should(QueryBuilders.matchQuery("description",searchText));
        boolQueryBuilder.should(QueryBuilders.matchQuery("content",searchText));
        boolQueryBuilder.minimumShouldMatch(1);
        }
        // 按标题检索
        if(StringUtils.isNotBlank(title)){
        boolQueryBuilder.should(QueryBuilders.matchQuery("title",title));
        boolQueryBuilder.minimumShouldMatch(1);
        }
        // 按内容检索
        if(StringUtils.isNotBlank(content)){
        boolQueryBuilder.should(QueryBuilders.matchQuery("content",content));
        boolQueryBuilder.minimumShouldMatch(1);
        }
        // 排序
        SortBuilder<?> sortBuilder=SortBuilders.scoreSort();
        if(StringUtils.isNotBlank(sortField)){
        sortBuilder=SortBuilders.fieldSort(sortField);
        sortBuilder.order(CommonConstant.SORT_ORDER_ASC.equals(sortOrder)?SortOrder.ASC:SortOrder.DESC);
        }
        // 分页
        PageRequest pageRequest=PageRequest.of((int)current,(int)pageSize);
        // 构造查询
        NativeSearchQuery searchQuery=new NativeSearchQueryBuilder().withQuery(boolQueryBuilder).withPageable(pageRequest).withSorts(sortBuilder).build();
        SearchHits<PostEsDTO> searchHits=elasticsearchRestTemplate.search(searchQuery,PostEsDTO.class);
```

## 数据同步

一般情况下,如果做查询搜索功能,使用ES来模糊搜索,但是数据以Mysql为主,所以需要把MySQL中的数据和ES进行同步,保证数据一致

- 4种方式
    - 1、定时任务（ 比如1分钟1次，同步最近Mysql几分钟改变的数据，同步到Es ）
      - 优点：简单易懂、占用资源少，不用第三方中间件
      - 缺点：有时差
    - 2、双写：更新数据时，必须同时去写ES （事务：先保证Mysql成功，如果ES写失败，可以通过定时任务 + 日志 + 告警进行检测和补偿）
    - 3、用Logstash数据同步管道（一般配合kafka 消息队列 + beats采集器）


## Logstash

传输和处理数据的管道